{"version":3,"file":"/packages/krstffr:spreadsheet-to-mongodb.js","sources":["krstffr:spreadsheet-to-mongodb/lib/spreadsheet-to-mongodb.js","krstffr:spreadsheet-to-mongodb/lib/spreadsheet-to-mongodb-server-methods.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,2C;;AAEA,iB;;AAEA,6B;AACA,iB;;;AAGA,2E;AACA,kF;AACA,iB;;AAEA,gC;AACA,sF;AACA,8E;AACA,8C;AACA,2B;AACA,oD;AACA,K;AACA,kB;AACA,G;;AAEA,+D;AACA,sE;AACA,G;AACA,4B;AACA,oC;;AAEA,wD;AACA,kE;AACA,K;;AAEA,kB;;AAEA,G;;AAEA,6B;AACA,E;AACA,iB;AACA,sD;AACA,iG;AACA,+B;AACA,M;AACA,G;AACA,G;AACA,E;AACA,e;AACA,sD;AACA,iG;AACA,6B;AACA,M;AACA,G;AACA,G;AACA,E;AACA,gB;AACA,sD;;AAEA,sC;AACA,4C;;AAEA,gE;AACA,0D;;AAEA,sC;AACA,mD;AACA,I;AACA,yB;AACA,kF;AACA,I;AACA,qC;AACA,yD;AACA,uB;AACA,kC;AACA,kB;AACA,O;;AAEA,kC;AACA,mE;;AAEA,sB;;AAEA,K;;AAEA,8D;;AAEA,+C;AACA,kC;AACA,6E;AACA,M;AACA,mB;;AAEA,G;AACA,E;AACA,G;;;AAGA,U;AACA,e;;AAEA,yB;;AAEA,gC;AACA,0B;AACA,G;;AAEA,iC;AACA,2B;AACA,G;;AAEA,yC;AACA,uB;AACA,6B;AACA,U;AACA,G;;AAEA,oD;AACA,kC;AACA,4B;AACA,oC;AACA,+C;AACA,6B;AACA,sC;AACA,a;AACA,G;AACA,c;AACA,G;;AAEA,0C;;AAEA,kD;AACA,6B;AACA,sC;AACA,mD;AACA,mC;;AAEA,qB;AACA,+B;AACA,6C;;AAEA,mD;AACA,yC;AACA,+B;AACA,uC;;AAEA,oC;AACA,iC;;AAEA,6C;;AAEA,G;;AAEA,qD;AACA,6C;;AAEA,0B;;AAEA,oE;AACA,mB;AACA,mF;;AAEA,qB;;AAEA,G;;AAEA,kB;AACA,uB;;AAEA,mC;AACA,wB;;AAEA,gF;AACA,2C;AACA,mD;AACA,0C;AACA,iD;AACA,6G;AACA,K;AACA,M;AACA,e;AACA,I;;AAEA,sF;AACA,yC;AACA,sE;AACA,iD;AACA,iF;AACA,M;AACA,mB;AACA,I;;AAEA,6E;;AAEA,W;;AAEA,4D;AACA,yC;AACA,qC;AACA,M;;AAEA,2F;AACA,mC;AACA,iD;;AAEA,8D;AACA,kD;AACA,Y;AACA,wB;;AAEA,yD;AACA,iC;AACA,wC;;AAEA,c;;AAEA,I;;AAEA,gD;;AAEA,0B;AACA,6B;;AAEA,kD;AACA,oD;;AAEA,uB;AACA,4C;AACA,4E;AACA,4F;AACA,gE;AACA,sE;;AAEA,yB;AACA,oD;;AAEA,oB;AACA,4C;;AAEA,6C;;AAEA,kF;AACA,iE;AACA,uF;AACA,mF;AACA,wE;;AAEA,kF;AACA,yC;AACA,M;;AAEA,6D;;AAEA,4C;AACA,qE;;AAEA,0C;AACA,sF;;AAEA,4B;AACA,iF;;AAEA,kD;AACA,0C;;AAEA,uD;AACA,wE;;AAEA,oB;;AAEA,M;;AAEA,iE;AACA,kC;AACA,I;AACA,+C;AACA,8C;;AAEA,4D;;AAEA,+B;;AAEA,I;;AAEA,8B;AACA,sF;AACA,+F;AACA,e;AACA,iC;AACA,O;AACA,I;;AAEA,uB;;AAEA,I;;AAEA,E;;AAEA,E;;AAEA,yD;;;;;;;;;;;;;;;;;;AC1SA,gB;AACA,iE;;AAEA,6D;;AAEA,4B;AACA,kB;;AAEA,qD;AACA,mE;;AAEA,wF;AACA,8B;AACA,oB;AACA,yF;AACA,4B;AACA,G;;AAEA,qC;AACA,qC;;AAEA,6C;AACA,6B;AACA,wB;;AAEA,gB;AACA,gE;AACA,G;AACA,K;;AAEA,gB;;AAEA,E;AACA,G","sourcesContent":["SpreadsheetToMongoDBHandler = function () {\n\n\tvar that = this;\n\n\t// Holder for all the forms!\n\tthat.forms = [];\n\n\n\t// Handling of \"types\", meaning input types, such as \"number\", \"date\" etc.\n\t// Used for making sure the input \"34\" of type \"numer\" will be 34 instead of \"34\"\n\tthat.types = {};\n\n\t// The default transform method\n\tthat.types.defaultTransformMethod = function ( formFields, inputRow, typeName, cb ) {\n\t\tvar fieldsOfType = _(_.where(formFields, { type: typeName })).pluck('name');\n\t\t_.each(fieldsOfType, function( fieldName ) {\n\t\t\tif (inputRow[fieldName])\n\t\t\t\tinputRow[fieldName] = cb( inputRow[fieldName] );\n\t\t});\n\t\treturn inputRow;\n\t};\n\n\t// Execute each approved type's tranformMethod on the inputRow\n\tthat.types.checkAllTypes = function ( inputRow, currentFormFields ) {\n\t\t\t\n\t\tcheck( inputRow, Object );\n\t\tcheck( currentFormFields, Array );\n\n\t\t_( that.types.approvedTypes ).each( function( type ) {\n\t\t\tinputRow = type.transformMethod( currentFormFields, inputRow );\n\t\t});\n\n\t\treturn inputRow;\n\n\t};\n\n\tthat.types.approvedTypes = [\n\t{\n\t\tname: 'number',\n\t\ttransformMethod: function ( formFields, inputRow ) {\n\t\t\treturn that.types.defaultTransformMethod(formFields, inputRow, this.name, function ( value ) {\n\t\t\t\treturn parseFloat( value );\n\t\t\t});\n\t\t}\n\t},\n\t{\n\t\tname: 'date',\n\t\ttransformMethod: function ( formFields, inputRow ) {\n\t\t\treturn that.types.defaultTransformMethod(formFields, inputRow, this.name, function ( value ) {\n\t\t\t\treturn new Date( value );\n\t\t\t});\n\t\t}\n\t},\n\t{\n\t\tname: 'array',\n\t\ttransformMethod: function ( formFields, inputRow ) {\n\n\t\t\t// This is the callback used below!\n\t\t\tvar cb = function ( value, arrayField ) {\n\n\t\t\t\t// Either use the user passed separator or the default comma\n\t\t\t\tvar arraySeparator = arrayField.arraySeparator || ',';\n\n\t\t\t\t// split() the value into an array\n\t\t\t\tvar arrayValue = value.split( arraySeparator );\n\t\t\t\t\n\t\t\t\t// trim() every item.\n\t\t\t\tarrayValue = _( arrayValue ).map( function( value ) { return value.trim(); });\n\t\t\t\t\n\t\t\t\t// Transform numbers into numbers\n\t\t\t\tarrayValue = _( arrayValue ).map( function( value ) {\n\t\t\t\t\tif (!isNaN(value))\n\t\t\t\t\t\tvalue = parseFloat( value );\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\n\t\t\t\tif (arrayField.arrayMaxLength)\n\t\t\t\t\tarrayValue = arrayValue.slice( 0, arrayField.arrayMaxLength );\n\n\t\t\t\treturn arrayValue;\n\n\t\t\t};\n\n\t\t\tvar arrayFields = _.where(formFields, { type: this.name });\n\n\t\t\t_.each(arrayFields, function( arrayField ) {\n\t\t\t\tif (inputRow[arrayField.name])\n\t\t\t\t\tinputRow[arrayField.name] = cb( inputRow[arrayField.name], arrayField );\n\t\t\t});\n\t\t\treturn inputRow;\n\n\t\t}\n\t}\n\t];\n\n\n\t// Logger\n\tthat.log = {};\n\n\tthat.log.enabled = true;\n\n\tthat.log.enable = function () {\n\t\tthat.log.enabled = true;\n\t};\n\n\tthat.log.disable = function () {\n\t\tthat.log.enabled = false;\n\t};\n\n\tthat.log.logMessage = function ( msg ) {\n\t\tif (that.log.enabled)\n\t\t\treturn console.log( msg );\n\t\treturn ;\n\t};\n\n\t// Method for hashing strings in a predictable way.\n\tthat.hashCode = function( str ) {\n\t\tvar hash = 0, i, chr, len;\n\t\tif (str.length === 0) return hash;\n\t\tfor (i = 0, len = str.length; i < len; i++) {\n\t\t\tchr   = str.charCodeAt(i);\n\t\t\thash  = ((hash << 5) - hash) + chr;\n\t\t\thash |= 0;\n\t\t}\n\t\treturn hash;\n\t};\n\n\tthat.addForm = function ( formOptions ) {\n\n\t\t// Make sure the user has provided correct types\n\t\tcheck(formOptions, Object);\n\t\tcheck(formOptions.formName, String);\n\t\tcheck(formOptions.collection, Meteor.Collection);\n\t\tcheck(formOptions.fields, Array);\n\n\t\t// Optional options\n\t\tif (formOptions.saveCallback)\n\t\t\tcheck(formOptions.saveCallback, Function);\n\n\t\t// .saveToDB should be a bool, and always be set \n\t\tif (formOptions.saveToDB === undefined)\n\t\t\tformOptions.saveToDB = true;\n\t\tcheck(formOptions.saveToDB, Boolean);\n\n\t\t// Add the form to the forms array\n\t\tthat.forms.push( formOptions );\n\n\t\treturn that.forms[ that.forms.length - 1 ];\n\n\t};\n\n\t// Get the current form from .optios (based on name)\n\tthat.getFormByName = function ( formName ) {\n\n\t\tcheck(formName, String);\n\n\t\tvar currentForm = _(that.forms).findWhere({ formName: formName });\n\t\tif (!currentForm)\n\t\t\tthrow new Error('You\\'re trying to get a form which does not exist: '+formName);\n\n\t\treturn currentForm;\n\n\t};\n\n\t// Client methods\n\tif (Meteor.isClient) {\n\n\t\t// Methods for handling the input\n\t\tthat.handleInput = {};\n\n\t\tthat.handleInput.checkRequiredFields = function ( requiredFields, inputRow ) {\n\t\t\t// Make sure all required fields are set\n\t\t\t_.each(requiredFields, function(requiredField) {\n\t\t\t\tif (!inputRow[ requiredField.name ]) {\n\t\t\t\t\tthat.log.logMessage({ errorDoc: inputRow });\n\t\t\t\t\tthrow new Error('Required field not set: ' + requiredField.name + '. See passed doc in the row above.');\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t};\n\n\t\tthat.handleInput.setDefaultValues = function ( fieldsWithDefaultValues, inputRow ) {\n\t\t\t// Set default values for unset values\n\t\t\t_.each(fieldsWithDefaultValues, function( fieldWithDefaultValue ) {\n\t\t\t\tif( !inputRow[ fieldWithDefaultValue.name ] )\n\t\t\t\t\tinputRow[ fieldWithDefaultValue.name ] = fieldWithDefaultValue.defaultValue;\n\t\t\t});\n\t\t\treturn inputRow;\n\t\t};\n\n\t\tthat.handleInput.createId = function ( _idFields, inputRow, currentForm ) {\n\n\t\t\tvar _id;\n\n\t\t\t// Generate an _id if there are _idFields set by the user\n\t\t\t_.each(_idFields, function(_idField) {\n\t\t\t\t_id += inputRow[ _idField.name ];\n\t\t\t});\n\n\t\t\t// Hash the _id and remove whitespaces (if the _id is generated by the users _idFields )\n\t\t\tif (_id && _idFields.length > 0)\n\t\t\t\t_id = that.hashCode( _id.replace(/ /g, '') );\n\n\t\t\t// If there is no _id set from _idFields (or explicitly by \n\t\t\t// setting { _id: 'something' }), generate one!\n\t\t\tif (!_id)\n\t\t\t\t_id = Meteor.uuid();\n\n\t\t\t// Add the userId to the _id if user set addUserIdToId\n\t\t\tif (currentForm.addUserIdToId)\n\t\t\t\t_id += Meteor.userId().substr(0,10);\n\n\t\t\treturn _id;\n\n\t\t};\n\n\t\tthat.saveData = function ( input, formName ) {\n\n\t\t\tcheck( input, String );\n\t\t\tcheck( formName, String );\n\n\t\t\t// Get the form passed to options based on name\n\t\t\tvar currentForm = that.getFormByName( formName );\n\n\t\t\t// Fix up input data\n\t\t\tinput = '\"'+input;\t\t\t\t\t\t\t\t\t\t// First line\n\t\t\tinput = input.replace(/\t/g, '\"\t\"');\t// Place qoutes before and after tabs\n\t\t\tinput = input.replace(/\\n/g, '\"\\n\"');\t// Place quotes on end line (and start of the next)\n\t\t\tinput = input.replace(/ \"/g, '\"');\t\t// Remove trailing spaces\n\t\t\tinput = input.replace(/\t/g, ',');\t\t\t// Replace all tabs with commas\n\n\t\t\t// Get the header row.\n\t\t\tvar header = _(currentForm.fields).pluck('name');\n\n\t\t\t// Add header-row\n\t\t\tinput = header.toString() + '\\n' + input;\n\n\t\t\tvar inputAsArray = $.csv.toObjects(input);\n\n\t\t\t// Get the idpart, number, date, required fields and fields with default values\n\t\t\tvar _idFields = _.where(currentForm.fields, { idpart: true });\n\t\t\tvar numberFields = _(_.where(currentForm.fields, { type: 'number' })).pluck('name');\n\t\t\tvar dateFields = _(_.where(currentForm.fields, { type: 'date' })).pluck('name');\n\t\t\tvar requiredFields = _.where(currentForm.fields, { required: true });\n\n\t\t\tvar fieldsWithDefaultValues = _.filter(currentForm.fields, function ( field ) {\n\t\t\t\tif (field.defaultValue) return field;\n\t\t\t});\n\n\t\t\tinputAsArray = _(inputAsArray).map( function( inputRow ) {\n\n\t\t\t\t// Make sure all required fields are set\n\t\t\t\tthat.handleInput.checkRequiredFields( requiredFields, inputRow );\n\n\t\t\t\t// Set default values for unset values\n\t\t\t\tinputRow = that.handleInput.setDefaultValues( fieldsWithDefaultValues, inputRow );\n\n\t\t\t\t// Cretate the _id field\n\t\t\t\tinputRow._id = that.handleInput.createId( _idFields, inputRow, currentForm );\n\n\t\t\t\t// Remove all values which have the REMOVE key\n\t\t\t\tinputRow = _(inputRow).omit('REMOVE');\n\n\t\t\t\t// Execute all the \"approvedTypes\" transformMethods\n\t\t\t\tinputRow = that.types.checkAllTypes( inputRow, currentForm.fields );\n\n\t\t\t\treturn inputRow;\n\n\t\t\t});\n\n\t\t\t// Check if the user has provided her own save callback method\n\t\t\tif (currentForm.saveCallback) {\n\t\t\t\t\n\t\t\t\t// Make sure the saveCallback is a Function\n\t\t\t\tcheck(currentForm.saveCallback, Function);\n\n\t\t\t\tinputAsArray = currentForm.saveCallback( inputAsArray );\n\n\t\t\t\tcheck(inputAsArray, Array);\n\n\t\t\t}\n\n\t\t\tif (currentForm.saveToDB) {\n\t\t\t\t// If the user has not provided a custom callback, execute the default save method\n\t\t\t\tMeteor.call('SpreadsheetToMongoDB/save', inputAsArray, formName, function (error, result) {\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tthat.log.logMessage(error);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn inputAsArray;\n\n\t\t};\n\n\t}\n\n};\n\nSpreadsheetToMongoDB = new SpreadsheetToMongoDBHandler();","Meteor.methods({\n\t'SpreadsheetToMongoDB/save': function ( collection, formName ) {\n\n\t\tcheck( SpreadsheetToMongoDB, SpreadsheetToMongoDBHandler );\n\n\t\t// Var to store the result\n\t\tvar result = [];\n\n\t\t// Get the submitted form from the passed form name\n\t\tvar currentForm = SpreadsheetToMongoDB.getFormByName( formName );\n\n\t\t// If the user has set addUserId == true, store it in a var for usage when saving docs\n\t\tif (currentForm.addUserId) {\n\t\t\tif (!this.userId)\n\t\t\t\tthrow new Meteor.Error(400, 'You need to be logged in to use this awesome feature.');\n\t\t\tvar userId = this.userId;\n\t\t}\n\n\t\t// Loop over every doc, and save it\n\t\t_.each(collection, function( doc ){\n\n\t\t\t// If addUserId == true, add it to the doc\n\t\t\tif (currentForm.addUserId)\n\t\t\t\tdoc.userId = userId;\n\n\t\t\t// Upsert it.\n\t\t\tresult.push( currentForm.collection.upsert( doc._id, doc ) );\n\t\t\t\n\t\t});\n\n\t\treturn result;\n\n\t}\n});"]}